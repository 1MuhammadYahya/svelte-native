import { SvelteComponent, init, safe_not_equal, noop, create_slot, assign, get_slot_context, add_binding_callback, bind, createText, setAttributes, insert, mount_component, getSpreadUpdate, detachNode, exclude_internal_props } from 'svelte/internal';

/* repl https://v3.svelte.technology/repl?version=3.0.0-alpha27&gist=623e9f32d2bcd103a45f26e1d9ce83ac */

/*
Generated from 
	<svelte:options bind:props={props}/>
	<slot props={props}/>
	<script> let props; </script> 
then 
   "let { $$slot_default, $$scope } = $$props;"
	 was removed and added to the AsComponent's "instance" function
*/

function createComponent($$slot_default, $$scope) {
    //const get_default_slot_changes = ({ props }) => ({ props: props });
    //const get_default_slot_context = ({ props }) => ({ props: props });

    const get_default_slot_context = ({ props }) => (assign({}, props));

    function create_fragment(ctx) {
        const default_slot_1 = ctx.$$slot_default;
        const default_slot = create_slot(default_slot_1, ctx, get_default_slot_context);
        const get_default_slot_changes = ({ props }) => {
            let changes = {};
            Object.keys(ctx.props).forEach(k => changes[k] = props);
            return changes;
        };

        return {
            c() {

                if (default_slot) default_slot.c();
            },

            l(nodes) {
                if (default_slot) default_slot.l(nodes);
            },

            m(target, anchor) {

                if (default_slot) {
                    default_slot.m(target, anchor);
                }
            },

            p(changed, ctx) {

                if (default_slot && (changed.$$scope || changed.props)) {
                    default_slot.p(assign(assign({}, get_default_slot_changes(changed)), ctx.$$scope.changed), get_slot_context(default_slot_1, ctx, get_default_slot_context));
                }
            },

            i: noop,
            o: noop,

            d(detach) {

                if (default_slot) default_slot.d(detach);
            }
        };
    }

    function instance($$self, $$props, $$invalidate) {
        let props = $$props;

        $$self.$set = $$props => {
            if (!props) props = {};
            assign(props, $$props);
            $$invalidate('props', props);
            if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
        };

        return { props, $$slot_default, $$scope };
    }

    return class extends SvelteComponent {
        constructor(options) {
            super();
            init(this, options, instance, create_fragment, safe_not_equal);
        }
    }
}

/*
Generated from 
		<script> export let component; </script> 
then modified
*/
function create_fragment(ctx) {
    return {
        c: noop,
        m: noop,
        p: noop,
        i: noop,
        o: noop,
        d: noop
    };
}

function instance($$self, $$props, $$invalidate) {
    let { $$slot_default, $$scope } = $$props;

    let component = createComponent($$slot_default, $$scope);

    return { component };
}

class AsComponent extends SvelteComponent {
    constructor(options) {
        super();
        init(this, options, instance, create_fragment, safe_not_equal);
    }

    get component() {
        return this.$$.ctx.component;
    }
}

/* src\components\Template.svelte generated by Svelte v3.0.0-beta.15 */

const get_default_slot_changes = ({ item }) => ({ item: item });
const get_default_slot_context = ({ item }) => ({ item: item });

// (2:0) <AsComponent bind:component="{template}" let:item>
function create_default_slot(ctx) {
	const default_slot_1 = ctx.$$slot_default;
	const default_slot = create_slot(default_slot_1, ctx, get_default_slot_context);

	return {
		c() {
			if (default_slot) default_slot.c();
		},

		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},

		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}
		},

		p(changed, ctx) {
			if (default_slot && (changed.$$scope || changed.item)) {
				default_slot.p(assign(assign({}, get_default_slot_changes(changed)), ctx.$$scope.changed), get_slot_context(default_slot_1, ctx, get_default_slot_context));
			}
		},

		d(detach) {
			if (default_slot) default_slot.d(detach);
		}
	};
}

function create_fragment$1(ctx) {
	var template_1, text, updating_component, current;

	var template_1_levels = [
		ctx.$$props,
		{ component: ctx.template },
		{ xmlns: "tns" }
	];

	var template_1_data = {};
	for (var i = 0; i < template_1_levels.length; i += 1) {
		template_1_data = assign(template_1_data, template_1_levels[i]);
	}

	function ascomponent_component_binding(value) {
		if (ctx.ascomponent_component_binding.call(null, value)) {
			updating_component = true;
		}
	}

	let ascomponent_props = {
		$$slot_default: [create_default_slot, ({ item }) => ({ item })],
		$$scope: { ctx }
	};
	if (ctx.template !== void 0) {
		ascomponent_props.component = ctx.template;
	}
	var ascomponent = new AsComponent({ props: ascomponent_props });

	add_binding_callback(() => bind(ascomponent, 'component', ascomponent_component_binding));

	return {
		c() {
			template_1 = document.createElementNS("tns", "template");
			text = createText("\r\n");
			ascomponent.$$.fragment.c();
			setAttributes(template_1, template_1_data);
		},

		m(target, anchor) {
			insert(target, template_1, anchor);
			insert(target, text, anchor);
			mount_component(ascomponent, target, anchor);
			current = true;
		},

		p(changed, ctx) {
			setAttributes(template_1, getSpreadUpdate(template_1_levels, [
				(changed.$$props) && ctx.$$props,
				(changed.template) && { component: ctx.template },
				{ xmlns: "tns" }
			]));

			var ascomponent_changes = {};
			if (changed.item) ascomponent_changes.$$scope = { changed, ctx };
			if (!updating_component && changed.template) {
				ascomponent_changes.component = ctx.template;
			}
			ascomponent.$set(ascomponent_changes);
			updating_component = false;
		},

		i(local) {
			if (current) return;
			ascomponent.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			ascomponent.$$.fragment.o(local);
			current = false;
		},

		d(detach) {
			if (detach) {
				detachNode(template_1);
				detachNode(text);
			}

			ascomponent.$destroy(detach);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let template;

	let { $$slot_default, $$scope } = $$props;

	function ascomponent_component_binding(value) {
		template = value;
		return $$invalidate('template', template)
	}

	$$self.$set = $$new_props => {
		$$invalidate('$$props', $$props = assign(assign({}, $$props), $$new_props));
		if ('$$scope' in $$new_props) $$invalidate('$$scope', $$scope = $$new_props.$$scope);
	};

	return {
		template,
		$$props,
		ascomponent_component_binding,
		$$props: $$props = exclude_internal_props($$props),
		$$slot_default,
		$$scope
	};
}

class Template extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal);
	}
}

export { AsComponent, Template };
