import { SvelteComponent, init, safe_not_equal, create_slot, get_slot_changes, get_slot_context, noop, assign, exclude_internal_props, add_binding_callback, bind, space, set_attributes, insert, mount_component, get_spread_update, detach } from 'svelte/internal';

/* src\components\SlotComponent.svelte generated by Svelte v3.0.0-beta.20 */

const get_default_slot_changes = ({ $$props }) => ({ props: $$props });
const get_default_slot_context = ({ $$props }) => ({ props: $$props });

function create_fragment(ctx) {
	const default_slot_1 = ctx.$$slot_default;
	const default_slot = create_slot(default_slot_1, ctx, get_default_slot_context);

	return {
		c() {
			if (default_slot) default_slot.c();
		},

		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},

		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}
		},

		p(changed, ctx) {
			if (default_slot && default_slot.p && (changed.$$scope || changed.$$props)) {
				default_slot.p(get_slot_changes(default_slot_1, ctx, changed, get_default_slot_changes), get_slot_context(default_slot_1, ctx, get_default_slot_context));
			}
		},

		i: noop,
		o: noop,

		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { $$slot_default, $$scope } = $$props;

	$$self.$set = $$new_props => {
		$$invalidate('$$props', $$props = assign(assign({}, $$props), $$new_props));
		if ('$$scope' in $$new_props) $$invalidate('$$scope', $$scope = $$new_props.$$scope);
	};

	return {
		$$props,
		$$props: $$props = exclude_internal_props($$props),
		$$slot_default,
		$$scope
	};
}

class SlotComponent extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, []);
	}
}

/* src\components\AsComponent.svelte generated by Svelte v3.0.0-beta.20 */

function create_fragment$1(ctx) {
	return {
		c: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};
}

function instance$1($$self, $$props, $$invalidate) {
	//copy our slot content and scope
    let slot_default = $$props.$$slot_default;
    let scope = $$props.$$scope;

    let { component = class extends SlotComponent {
        constructor(options) {
            //force instances of this component to use our slot content and scope.
            let new_options = Object.assign({}, options);
            new_options.props = Object.assign({}, options.props, { $$slot_default: slot_default, $$scope: scope });
            super(new_options);
        }
    } } = $$props;

	$$self.$set = $$new_props => {
		$$invalidate('$$props', $$props = assign(assign({}, $$props), $$new_props));
		if ('component' in $$props) $$invalidate('component', component = $$props.component);
	};

	return {
		component,
		$$props: $$props = exclude_internal_props($$props)
	};
}

class AsComponent extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, ["component"]);
	}
}

/* src\components\Template.svelte generated by Svelte v3.0.0-beta.20 */

const get_default_slot_changes$1 = ({ props }) => ({ item: props });
const get_default_slot_context$1 = ({ props }) => ({ item: (props ? props.item : null) });

// (2:0) <AsComponent bind:component="{template}" let:props>
function create_default_slot(ctx) {
	const default_slot_1 = ctx.$$slot_default;
	const default_slot = create_slot(default_slot_1, ctx, get_default_slot_context$1);

	return {
		c() {
			if (default_slot) default_slot.c();
		},

		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},

		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}
		},

		p(changed, ctx) {
			if (default_slot && default_slot.p && (changed.$$scope || changed.props)) {
				default_slot.p(get_slot_changes(default_slot_1, ctx, changed, get_default_slot_changes$1), get_slot_context(default_slot_1, ctx, get_default_slot_context$1));
			}
		},

		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$2(ctx) {
	var template_1, t, updating_component, current;

	var template_1_levels = [
		ctx.$$props,
		{ component: ctx.template },
		{ xmlns: "tns" }
	];

	var template_1_data = {};
	for (var i = 0; i < template_1_levels.length; i += 1) {
		template_1_data = assign(template_1_data, template_1_levels[i]);
	}

	function ascomponent_component_binding(value) {
		if (ctx.ascomponent_component_binding.call(null, value)) {
			updating_component = true;
		}
	}

	let ascomponent_props = {
		$$slot_default: [create_default_slot, ({ props }) => ({ props })],
		$$scope: { ctx }
	};
	if (ctx.template !== void 0) {
		ascomponent_props.component = ctx.template;
	}
	var ascomponent = new AsComponent({ props: ascomponent_props });

	add_binding_callback(() => bind(ascomponent, 'component', ascomponent_component_binding));

	return {
		c() {
			template_1 = document.createElementNS("tns", "template");
			t = space();
			ascomponent.$$.fragment.c();
			set_attributes(template_1, template_1_data);
		},

		m(target, anchor) {
			insert(target, template_1, anchor);
			insert(target, t, anchor);
			mount_component(ascomponent, target, anchor);
			current = true;
		},

		p(changed, ctx) {
			set_attributes(template_1, get_spread_update(template_1_levels, [
				(changed.$$props) && ctx.$$props,
				(changed.template) && { component: ctx.template },
				{ xmlns: "tns" }
			]));

			var ascomponent_changes = {};
			if (!updating_component && changed.template) {
				ascomponent_changes.component = ctx.template;
			}
			ascomponent.$set(ascomponent_changes);
			updating_component = false;
		},

		i(local) {
			if (current) return;
			ascomponent.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			ascomponent.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				detach(template_1);
				detach(t);
			}

			ascomponent.$destroy(detaching);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let template;

	let { $$slot_default, $$scope } = $$props;

	function ascomponent_component_binding(value) {
		template = value;
		return $$invalidate('template', template)
	}

	$$self.$set = $$new_props => {
		$$invalidate('$$props', $$props = assign(assign({}, $$props), $$new_props));
		if ('$$scope' in $$new_props) $$invalidate('$$scope', $$scope = $$new_props.$$scope);
	};

	return {
		template,
		$$props,
		ascomponent_component_binding,
		$$props: $$props = exclude_internal_props($$props),
		$$slot_default,
		$$scope
	};
}

class Template extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, []);
	}
}

export { Template };
